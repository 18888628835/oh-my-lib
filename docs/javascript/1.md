# 由 this 到 RefrenceType 的思考

## JS 的作用域问题

在讨论 this 之前，需要先阐述现代语言中的两种底层作用域：

1. 词法作用域
2. 动态作用域

JavaScript 是词法作用域，让我们从一段代码开始观察：

```javascript
function fn() {
  console.log(a);
}
function fn2() {
  var a = 1;
  fn();
}
fn2();
// Uncaught ReferenceError: a is not defined
```

上面的代码会输出`ReferenceError`，意味着变量 a 的引用没有被找到。

这说明函数执行时，它并不会在当前所在的环境下去找寻该作用域下的变量。

即 `fn()`调用时，在 `fn` 内部的变量 `a`并不是 `fn2`函数里的`a`。

这里的词法作用域指的是，当我们写下`function fn(){...}`时，这个函数所能访问的作用域已经被创建并且指定到了——全局作用域。在全局作用域下没有变量`a`，于是抛出一个“引用错误”。

修改成以下代码，我们可以证明这点：`fn`里的变量 `a`访问到的是全局作用域下的 `a`。

```js
var a = 'global scope variable a';
function fn() {
  console.log(a);
}
function fn2() {
  var a = 1;
  fn();
}
fn2();
// global scope variable a
```

动态作用域则不需要关心书写时函数定义在哪里，而是考虑代码在哪运行。

如果 JavaScript 是动态作用域，那么当`fn`函数调用时才会生成它能访问的作用域。

这意味上上面代码打印出来的结果会变成`1`。

现在，我们来区分一下词法作用域和动态作用域的差别：

- 词法作用域更关心的是书写，代码写在哪其实就定义好了作用域
- 动态作用域不关心书写，而是你在哪调用，哪就产生作用域

那么，JavaScript 中有没有一种东西跟动态作用域一样是随着执行环境变化而变化的呢？

答案是——this

## this 全面解析

this 既不指向函数自身也不指向函数的词法作用域。

this 实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。

### 函数的调用位置

调用位置是函数在代码中被调用的位置（而不是声明的位置）。只有仔细分析调用位置才能回答这个问题：这个 this 到底引用的是什么？

要找调用位置，不单单是找到调用位置的代码那么简单，因为有时候我们可能难以通过单纯的代码来找位置。

我们需要通过调用栈来找到调用位置。

什么是当前调用栈？当前调用栈就是代码执行时候所处在哪个当前函数，而调用位置就是当前执行函数之前调用的位置。

继续用一段代码来分析：

```
function fn(){
		// *2 调用fn时的当前调用栈
    // *2 此时fn调用位置是全局作用域
	...
    fn1() // *3 fn1的调用位置
}
function fn1(){
	//当前调用栈从fn => fn1
	...
    fn2() // fn2的调用位置
}
function fn2(){
	//当前调用栈从fn1 => fn2
	...
}
fn() // *1 调用 fn
```
