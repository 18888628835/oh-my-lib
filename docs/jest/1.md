# 基础实践

## hello world

### 创建项目

```bash
cd jest-start
npm init -y
npm i -D jest
npx jest --init
```

安装 Jest 后用`jest-cli`初始化 `jest` 配置文件,刚开始先使用以下配置

![image-20221015133110662](../assets/image-20221015133110662.png)

执行完之后，会生成`jest.config.js`的配置文件

### 使用 JavaScript 测试

下面用 JavaScript 进行 Hello world 测试

```js
// src/utils/sum.js
const sum = (a, b) => {
  return a + b;
};

module.exports = sum;
```

```js
// src/utils/sum.test.js
const sum = require('../utils/sum');

describe('sum', () => {
  it('可以相加', () => {
    expect(sum(1, 1)).toEqual(2);
  });
});
```

此时项目结构

```bash
├── package-lock.json
├── package.json
└── src
    ├── tests
    │   └── sum.test.js
    └── utils
        └── sum.js
```

启动测试：

```
npm run test
```

得到测试报告

<img src="../assets/image-20221015133941095.png" alt="image-20221015133941095" style="zoom:100%;" />

### 自动运行 jest

如果希望能够在修改 test 文件后自动运行 jest，我们需要在`package.json`的脚本命令后加上`--watchAll`：

```json
  "scripts": {
    "test": "jest --watchAll"
  },
```

`--watchAll` 会在变更后测试所有的文件。

如果只希望测试变更过的文件，则可以改成

```json
  "scripts": {
    "test": "jest --watch"
  },
```

在该模式下，会自动运行 `o 模式` ——参见 [测试时命令模式](#测试时命令模式)

### 单文件测试

如果只想要测试一个 js 文件，则使用以下命令：

```bash
npm run test <文件相对路径>
```

例如：

```bash
 npm run test ./src/tests/sum.test.js
```

### 覆盖率报告

终端展示的是覆盖率情况，还有更加详细的覆盖率报告。

覆盖率报告在新生成的`coverage`目录中，有不同格式的覆盖率报告

```bash
├── clover.xml
├── coverage-final.json
├── lcov-report
│   ├── base.css
│   ├── block-navigation.js
│   ├── favicon.png
│   ├── index.html
│   ├── prettify.css
│   ├── prettify.js
│   ├── sort-arrow-sprite.png
│   ├── sorter.js
│   └── sum.js.html
└── lcov.info
```

我们可以打开 index.html 来查看网页版本的报告

```js
cd coverage/lcov-report
hs -c-1 . // 用 http-server 打开index.html
```

![image-20221015134822930](../assets/image-20221015134822930.png)

## 支持 TypeScript

想要支持 TypeScript，就必须转译 ts 代码。

Jest 本身不支持代码转译。在执行时会调用**转译器/编译器**做代码转译。所以就能够对 TypeScript 转译成 JS 代码从而让 Jest 支持对 TypeScript 的测试。

### TSC 转译

项目里安装 TypeScript

```bash
npm i -D typescript
```

生成 TypeScript 配置文件

```bash
tsc --init
```

安装 ts-jest 模块和 jest 的类型声明文件

```bash
npm i -D ts-jest
npm i -D @types/jest
```

> ts-jest 的大版本要和 jest 的一致，否则容易产生兼容问题。

在`jest.config.js`中添加配置：

```json
module.exports = {
  preset: 'ts-jest',
  transform: {
    '^.+\\.ts?$': 'ts-jest',
  },
  ...
  }
```

将 sum.js 修改成 sum.ts

```js
export const sum = (a: number, b: number) => {
  return a + b;
};
```

将 `sum.test.js` 修改成 `sum.test.ts`

```js
import { sum } from '../utils/sum';

describe('sum', () => {
  it('可以相加', () => {
    expect(sum(1, 1)).toEqual(2);
  });
});
```

最后执行

```bash
npm run test
```

### babal 转译

由于 Babel 转译并不能让 Jest 做类型检查，所以推荐使用`ts-jest`。如果是纯 js 项目，则可以使用`babel-jest`来转译。

[官网教程 ](https://jestjs.io/docs/getting-started#using-typescript-via-babel)

### 路径别名

所谓路径别名就是我希望从这个引入：

```js
import { sum } from '../utils/sum';
```

换成这个引入

```js
import { sum } from 'utils/sum';
```

实际上就是把`utils`映射成`src/utils`。

首先要在 `moduleDirectories`中配置

```json
// jest.config.js
 moduleDirectories: ['node_modules', 'src'],
```

这里的意思是让 jest 可以直接到 `node_modules` 或者 `src` 下去找文件。

其次在`tsconfig`中配置 path

```js
    "baseUrl": "./",
    "paths": {
      "utils/*": ["src/utils/*"]
    },
```

这样 ts 文件就能够按照 paths 的配置去对应的映射路径中找到该文件。

但是如果要改成这样引入：

```js
import { sum } from '@/utils/sum';
```

`@`代表`src`。

jest 想要识别这个符号就需要在`moduleNameMapper`中配置：

```js
modulex.exports = {
  moduleNameMapper: { '@/(.*)': '<rootDir>/src/$1' },
};
```

这是 jest 的路径匹配。

然后 tsconfig 中也加入对`@`的映射。

```js
    "baseUrl": "./",
    "paths": {
      "utils/*": ["src/utils/*"],
      "@/*": ["src/*"]
    },
```

此时我们就可以用两种方式引入啦

```js
import { sum } from '@/utils/sum';
// import { sum } from 'utils/sum';

describe('sum', () => {
  it('可以相加', () => {
    expect(sum(1, 1)).toEqual(2);
  });
});
```

### 小结

1. 要让 Jest 支持 TypeScript，需要用到转译器，主流的转译器有两个：tsc 和 babel。tsc 能让 Jest 支持类型检查，所以更推荐使用
2. 能够通过路径别名来让 `Jest` 识别路径映射。除了在 `tsconfig` 中写路径别名外，还需要在 `jest.config.js` 中配置`moduleDirectories` 和 `moduleNameMapper`来实现

## 匹配器 matcher

匹配器有很多种，常见的有：

- toBe 匹配简单数据类型是否相等
- toEqual 深度匹配对象内容相等
- toBeNull 是否为 null
- toBeUndefined 是否为 undefined
- toBeFalsy 是否为 假值
- toBeDefined 是否为非 undefined
- toBeTruthy 是否为 真值
- not.to<xxx> 匹配器取反
- toBeGreaterThan 比某个大
- toBeLessThan 比某个小
- toBeGreaterThanOrEqual 大于或者等于
- toBeLessThanOrEqual 小于或者等于
- toBeCloseTo 是否等于,用于浮点数的计算，例如 0.1+0.2=0.3
- toMatch 字符串是否匹配
- toContain 数组或者 Set 结构是否包含一个项
- toThrow 是否抛出一个异常,可以传入字符串检查抛出的内容
- toMatchObject 匹配对象的内容

...等等

## 测试时命令模式

![image-20221023223817345](../assets/image-20221023223817345.png)

- f 只跑失败的用例
- o 只测试改变的文件（配合 git 使用,相当于 --watch）
- p 根据正则表达式测试对应的文件名里的用例
- t 根据正则表达式测试 test 函数里对应的 name 的用例
- q 退出 watch 模式
- i 以交互方式运行失败的测试用例
- enter 重新触发一次测试
- a 测试 all 文件（相当于 --watchAll）

## 测试异步代码

### 测试 callback

```js
// fetchData.ts
import axios from 'axios';

export async function fetchData(callback: (d: any) => void) {
  const api = 'https://api.github.com/users/18888628835';
  axios.get(api).then(res => callback(res.data));
}
```

```js
// fetchData.test.ts
import { fetchData } from '../utils/fetchData';

describe('测试异步函数', () => {
  it('fetchData callback', done => {
    fetchData(res => {
      expect(res.login).toBe('18888628835');
      done();
    });
  });
});
```

`callback` 会在 `then` 后进入微任务队列，这时候`fetchData`函数已经调用完毕了。我们该如何告诉 jest，还需要等异步函数调用结束测试才算完成?

jest 提供了一个 done 函数，只有 done 函数执行完成，才表示测试的异步函数调用结束了。

### 测试 promise

通过 async await 来测试 promise

```js
import axios from 'axios';

describe('测试异步函数', () => {
  function fetchData() {
    const api = 'https://api.github.com/users/18888628835';
    return axios.get(api);
  }

  it('fetchData', async () => {
    const res = await fetchData();
    expect(res.data.login).toBe('18888628835');
  });
});
```

通过 **then** 和 **return**

```js
describe('测试异步函数', () => {
  function fetchData() {
    const api = 'http://www.dell-lee.com/react/api/demo.json';
    return axios.get(api);
  }
  it('fetchData', () => {
    return fetchData().then(res => {
      expect(res.data).toEqual({ success: true });
    });
  });
});
```

通过 **resolves**

```js
describe('测试异步函数', () => {
  function fetchData() {
    const api = 'http://www.dell-lee.com/react/api/demo.json';
    return axios.get(api);
  }
  it('fetchData', () => {
    return expect(fetchData()).resolves.toMatchObject({
      data: { success: true },
    });
  });
});
```

### 测试是否能 catch 到 error

通过**catch 和 assertions**

```js
import axios from 'axios';

describe('测试异步函数', () => {
  function fetchData() {
    const api = 'http://www.dell-lee.com/react/api/demo2.json';
    return axios.get(api);
  }
  it('fetchData fails with error', () => {
    expect.assertions(1);
    return fetchData().catch(e => {
      console.log('🚀🚀🚀🚀🚀 - e:', e.toString()); //e: AxiosError: Request failed with status code 404
      expect(e.toString().indexOf('404') > -1).toBe(true);
    });
  });
});
```

通过`expect.assertions`断言 expect 至少能够执行一次。

否则上面的代码即使没有 catch 到 error，也能通过测试。因为 fetchData 顺利执行了。

通过 **rejects**和**toThrow**

```js
describe('测试异步函数', () => {
  function fetchData() {
    const api = 'http://www.dell-lee.com/react/api/demo1.json';
    return axios.get(api);
  }
  it('fetchData', () => {
    return expect(fetchData()).rejects.toThrow();
  });
});
```

通过 **try** 和 **catch**

```js
describe('测试异步函数', () => {
  function fetchData() {
    const api = 'http://www.dell-lee.com/react/api/demo1.json';
    return axios.get(api);
  }
  it('fetchData', async () => {
    expect.assertions(1);
    try {
      await fetchData();
    } catch (error) {
      if (error instanceof Error) {
        expect(error.toString()).toMatch('Error');
      }
    }
  });
});
```

## 钩子函数

钩子函数是自动运行的回调函数。Jest 允许每次在执行测试前后自动运行钩子函数里注册的函数。

### beforeAll

例如，下面有一个 Counter 类

```js
export class Counter {
  number;
  constructor() {
    this.number = 0;
  }
  addOne() {
    this.number += 1;
  }
  minusOne() {
    this.number -= 1;
  }
}
```

它有一个`addOne` 和一个`minusOne` 的方法

当我对这两个函数进行测试

```js
import { Counter } from '../utils/counter';

let counter: Counter;

describe('测试 counter', () => {
  beforeAll(() => {
    console.log('beforeAll', counter);
    counter = new Counter();
  });

  it('测试 addOne', () => {
    counter.addOne();
    expect(counter.number).toBe(1);
  });

  it('测试 minusOne', () => {
    counter.minusOne();
    expect(counter.number).toBe(0);
  });
});
```

上面的代码使用`beforeAll`这个钩子函数，执行 it 函数前，都会调用`beforeAll`函数里的代码初始化 `counter` 变量。

### afterAll

与上面对应，当执行完所有 it 函数后，会调用 afterAll 钩子函数。

### beforeEach

每一个`it` 函数执行前，都会执行 beforeEach 钩子函数。

```js
describe('测试 counter', () => {
  beforeEach(() => {
    counter = new Counter();
  });

  it('测试 addOne', () => {
    counter.addOne();
    expect(counter.number).toBe(1);
  });

  it('测试 minusOne', () => {
    counter.minusOne();
    expect(counter.number).toBe(-1);
  });
});
```

上面的代码在每次执行 it 函数前，都会调用一下 beforeEach 里的函数将 counter 初始化为一个新的 Counter 实例，这样做的好处是能够保证各个 it 函数内的数据不受互相的影响。

### afterEach

与 beforeEach 对应，在每个 it 函数调用之后会执行 afterEach 注册的函数。

### describe

describe 函数是分组函数，也是一个钩子函数。

在一个 test 文件中使用多个分组函数能够帮助梳理不同的逻辑。

describe 内的钩子函数是有作用域的。比如以下代码：

```js
import { Counter } from '../utils/counter';

let counter: Counter;
beforeEach(() => {
  console.log('我的作用域全体');
  counter = new Counter();
});
describe('测试 加法', () => {
  beforeEach(() => {
    console.log('我的作用域在里面');
  });
  it('测试 addOne', () => {
    counter.addOne();
    expect(counter.number).toBe(1);
  });
  it('测试 addOne', () => {
    counter.addOne();
    expect(counter.number).toBe(1);
  });
});

describe('测试 减法', () => {
  it('测试 minusOne', () => {
    counter.minusOne();
    expect(counter.number).toBe(-1);
  });
  it('测试 minusOne', () => {
    counter.minusOne();
    expect(counter.number).toBe(-1);
  });
});
```

第一个 beforeEach 是全局的，每一个 describe 函数内的 it 执行前都会执行它。

第二个 beforeEach 只在第一个 describe 内有作用。

## 测试环境

假设现在我需要对 localStorage 进行操作,我封装了两个函数：

```js
// utils/storage.ts
function set(key: string, value: any) {
  localStorage.setItem(key, JSON.stringify(value));
}
function get(key: string) {
  let value = localStorage.getItem(key);
  if (value) {
    return JSON.parse(value);
  }
  return undefined;
}
export default { set, get };
```

然后写对应的测试用例

```js
// tests/storage.test.ts
import local from 'utils/storage';
describe('测试 localStorage', () => {
  it(' set 数据', () => {
    local.set('value1', { name: 'qiuyanxi' });
    expect(local.get('value')).toEqual({ name: 'qiuyanxi' });
  });
});

describe('测试 localStorage', () => {
  it('key 正确则能够获取正确数据', () => {
    local.set('value2', 'hello jest');
    expect(local.get('value2')).toEqual('hello jest');
  });
  it('key 不正确则能够获取到 undefined', () => {
    local.set('value1', 'hello jest');
    expect(local.get('value2')).toEqual(undefined);
  });
});
```

但是在`npm run test`的时候，会发现 node 环境下并没有`localStorage`

![image-20221016005905540](../assets/image-20221016005905540.png)

这里有两种方法可以在环境中设置：

- 全局 Mock - 创建 localStorage 的 全局变量，并让它的实现跟浏览器环境中的类似
- 使用 jsdom 来创建虚拟的浏览器环境

### 全局 Mock

全局 Mock 可以帮助我们设置 localStorage 这个全局变量，分成两步：

1. 创建 global.localStorage 这个全局变量
2. 告诉 jest，我要在测试前先设置 global.localStorage —— 通过`setupFilesAfterEnv`选项

第一步：创建`tests/jest-setup.ts`文件

```js
Object.defineProperty(global, 'localStorage', {
  value: {
    store: {},
    setItem(key: string, value: string) {
      this.store[key] = value;
    },
    getItem(key: string) {
      return this.store[key];
    },
  },
});
```

上面的代码是在全局中设置一个 `localStorage` 的变量，并且它的 API 跟浏览器环境的相同。

第二步：在`jest.config.js` 中配置

```json
  setupFilesAfterEnv: ['./src/tests/jest-setup.ts'],
```

设置完这个属性后，`jest-setup.ts`会在**每个测试文件执行前先执行一次**,相当于每执行测试时，都会在全局添加 localStorage 的 Mock 数据。

> 跟 `setupFilesAfterEnv` 类似还有一个 `setupFiles` 选项，它也可以用来设置全局 Mock 数据。
>
> ![image-20221016031742426](../assets/image-20221016031742426.png)
>
> `setupFiles` 比 `setupFilesAfterEnv`更早执行，所以也可以用来设置 Mock 全局变量。
>
> 不同之处在于，由于`setupFilesAfterEnv`是在引入测试框架 Jest 之后运行的，所以能够在此引入和配置`Jset/Jasmine`的插件。
>
> 如果在`setupFiles`中添加 Jest 的扩展和插件，就会得到报错。
>
> 这里有个 [issue](https://github.com/testing-library/jest-dom/issues/122#issuecomment-650520461) 可以参考

执行`npm run test`,就能够获得测试情况报告。

### jsdom 环境

为了还原浏览器的全部功能，还可以引入 jest 提供的 jsdom 环境。

```json
// jest.config.js
testEnvironment: "jsdom",
```

添加后，就能拥有一个全局的、完整的浏览器标准的 API。原理是使用了[jsdom](https://github.com/jsdom/jsdom),这个库用 JS 实现了一套 Node.js 环境下的 Web 标准 API。由于 Jest 的测试文件也是在 Node.js 环境下执行的，所以 Jest 用这个库充当浏览器环境的 Mock 实现。

现在暂时注释`setupFilesAfterEnv`，重新执行`npm run test`，也能够获得测试情况报告

![image-20221016032718568](../assets/image-20221016032718568.png)

### 小结

1. 通过 `setupFiles` 或者`setupFilesAfterEnv`添加一个指定文件，这个指定文件可以放置全局 Mock 或者其他的一些操作
2. 通过`testEnvironment: "jsdom"`来创建一个 Nodejs 的浏览器环境

## 如何 Mock 网页地址

虽然通过 jsdom 配置了浏览器环境，但是依然有不少难搞的地方。比如网页路径。

下面有一个函数能够将网页的地址变成 object。

```js
// getUrlObject.ts
export function getUrlObj() {
  let urlObj = new URL(window.location.href);
  let obj = {};
  for (let key in urlObj) {
    if (['protocol', 'search', 'hash', 'href', 'pathname'].includes(key)) {
      Object.assign(obj, { [key]: urlObj[key as keyof typeof urlObj] });
    }
  }
  return obj;
}
```

接着是对其的测试文件

```js
// utils/getUrlObject.test.ts
import { getUrlObj } from 'utils/getUrlObject';

describe('测试网页地址', () => {
  it('将网页地址映射成正确的 object 对象', () => {
    window.location.href = 'https://baidu.com/hello-jest?name=qyx#age';
    expect(getUrlObj()).toEqual({
      href: 'https://baidu.com/hello-jest?name=qyx#age',
      search: '?name=qyx',
      hash: '#age',
      protocol: 'https:',
      pathname: '/hello-jest',
    });
  });
});
```

然而执行 test 后会得到以下报错：

![image-20221016085200589](../assets/image-20221016085200589.png)

这说明 jsdom 不能直接用`window.location.href`这个 API 测试。

### jest-location-mock

有一个优雅的实现方法：[jest-location-mock](https://www.npmjs.com/package/jest-location-mock)，这个包提供修改和获取 url 的功能。

首先安装

```bash
npm i -D jest-location-mock
```

安装完包之后，需要在 jest 测试框架启动前装载上去。将之前注释过的`setupFilesAfterEnv`配置放开

```json
 setupFilesAfterEnv: ['./src/tests/jest-setup.ts'],
```

然后在`jest-setup.ts`中引入该包

```js
// 使用扩展包来 Mock 'window.location'
import 'jest-location-mock';
```

最后运行`npm run test`得到结果

![image-20221016092328983](../assets/image-20221016092328983.png)

### 小结

对于网页地址的修改和测试可以使用 jest-location-mock 来扩展 jsdom 的能力。

扩展的使用方法是先配置`setupFilesAfterEnv` 选项，然后在 setup 文件中引入，使其变成全局 Mock。

## TDD

TDD(测试驱动开发)是一种非常好的开发模式，原理是：**先写测试，再写业务代码，当所有测试用例都通过后，业务代码的实现也呼之欲出了**。

![img](../assets/cycle.de98a7f0.jpg)

- 红色部分：在添加新功能前先写测试用例，同时这也是一个帮助缕逻辑的过程
- 绿色部分：开始添加业务代码来让测试通过
- 重构部分：回头审视自己的代码，将其重构成可读性和维护性高的代码。（同时重构后，测试用例会帮助检查重构后的逻辑是否有漏洞）
- ...重复上述过程

TDD 的主要作用并不是保证代码质量，而是创造一个更好的开发环境，在此基础上保证代码的主要逻辑正确 ✅。

### 实战一个 search 转化功能

下面有一个需求：

> 实现一个函数，该函数能够获取 url，然后将其 search 转化成对象。如果 search 不存在，则返回空对象
>
> 如果有传递参数，且参数为`xx=xxx&yy=yyy`字符串时，能够将其解析成`{xx:xxx,yy:yyy}`
>
> - `https://baidu.com?name=qyx` ===> `{ name: 'qyx' }`
> - `https://baidu.com` ===> `{}`
> - `?name=qyx&age=30` ===> `{ name: 'qyx',age: 30 }`

根据需求，我们先写好测试文件：

```js
import { transformSearch } from 'utils/transformSearch';

describe('将url 的 searchString 变成 object', () => {
  it('能正确转化成对象', () => {
    window.location.href = 'https://baidu.com?name=qyx&age=30#hello-jest';
    expect(transformSearch()).toEqual({ name: 'qyx', age: '30' });
  });

  it('无searchString 但有 ? 时解析出空对象', () => {
    window.location.href = 'https://baidu.com?#hello-jest';
    expect(transformSearch()).toEqual({});
  });

  it('无searchString 无 ? 时解析出空对象', () => {
    window.location.href = 'https://baidu.com#hello-jest';
    expect(transformSearch()).toEqual({});
  });

  it('传入?name=qyx&age=30解析成正确对象', () => {
    expect(transformSearch('?name=qyx&age=30')).toEqual({
      name: 'qyx',
      age: '30',
    });
  });

  it('传入name=qyx&age=30解析成正确对象', () => {
    expect(transformSearch('name=qyx&age=30')).toEqual({
      name: 'qyx',
      age: '30',
    });
  });

  it('传入https://baidu.com?name=qyx&age=30#hello-jest解析成正确对象', () => {
    expect(
      transformSearch('https://baidu.com?name=qyx&age=30#hello-jest'),
    ).toEqual({ name: 'qyx', age: '30' });
  });

  it('传入空字符串解析成空对象', () => {
    expect(transformSearch('')).toEqual({});
  });
});
```

通过 `window.location.href`来转化成对象，我们很容易写出来：

```js
export function transformSearch(searchString?: string) {
  if (searchString) {
  } else {
    let searchString = new URL(window.location.href).search;
    searchString = searchString.replace(/\?/g, '');
    return Object.fromEntries(new URLSearchParams(searchString).entries());
  }
}
```

测试后能通过大部分用例，只剩通过 searchString 参数的逻辑是失败的。通过用例，我们能分析出用户可能会传递三种情况：

1. 带问号的查询字符串
2. 不带问号的查询字符串
3. 带问号的整个 URL 连接
4. 传入一个空字符串

整个 URL 可以传递给 `new URL()`来构造一个 URL 对象，而其他的非 url 传进去会报错。所以我们可以这么写：

```js
export function transformSearch(searchString?: string) {
  if (searchString) {
    try {
      let searchStr = new URL(searchString).search;
      searchStr = searchStr.replace(/\?/g, '');
      return Object.fromEntries(new URLSearchParams(searchStr).entries());
    } catch (error) {
      let searchStr = searchString.replace(/\?/g, '');
      return Object.fromEntries(new URLSearchParams(searchStr).entries());
    }
  } else {
    let searchString = new URL(window.location.href).search;
    searchString = searchString.replace(/\?/g, '');
    return Object.fromEntries(new URLSearchParams(searchString).entries());
  }
}
```

执行`npm run test`查看到所有用例已经通过

![image-20221017214314575](../assets/image-20221017214314575.png)

现在可以优化代码啦,将它们共有的逻辑抽离出来即可:

```js
function getObjFromSearch(search: string) {
  let searchString = search.replace(/\?/g, '');
  return Object.fromEntries(new URLSearchParams(searchString).entries());
}
export function transformSearch(searchString?: string) {
  if (searchString) {
    try {
      return getObjFromSearch(new URL(searchString).search);
    } catch (error) {
      return getObjFromSearch(searchString);
    }
  }
  return getObjFromSearch(new URL(window.location.href).search);
}
```

重新执行`npm run test`,所有测试用例依然通过了。

即使重构再多代码，测试用例也能帮助我们兜底，避免重构后影响主逻辑的尴尬。

### 小结

有两种主要开发模式：

- TDD - 测试驱动开发，即先写测试用例，再根据它们补充业务代码
- BDD - 先写业务，再对重要的部分补充测试

TDD 的好处是我们在前期不仅能够对要做的功能有一个清晰的逻辑整理，还能够在后期重构代码时对主逻辑兜底，不陷入重构后主逻辑出问题的境地。

## 如何 Mock 时间

### 检测函数是否调用

现在有一个函数

```js
// src/utils/after1000ms.ts
type AnyFunction = (...rest: any[]) => any;

export function after1000ms(callback?: AnyFunction) {
  // 这里有大量的逻辑，用 for 循环代替
  for (let i = 0; i < 100000; i++) {}
  setTimeout(() => {
    callback && callback();
  }, 1000);
}
```

这个函数会传入一个 callback，并且在 1000 秒后执行 callback。假设我希望知道传入的 callback 有没有被调用，该如何做?

在 it 的回调函数 `ProvidesCallback`中有一个 cb 参数，即 `DoneCallback`。我们只需要在调用`after1000ms`后调用一下这个`DoneCallback`,就能够通知 Jest 被测试的函数被调用过了。具体代码如下：

```js
// src/tests/after1000ms.test.ts
import { after1000ms } from 'utils/after1000ms';
describe('after1000ms', () => {
  it('测试函数被调用了', done => {
    after1000ms(() => {
      expect('函数被调用了');
      done();
    });
  });
});
```

### 检测时间

上面的测算没办法预估时间，我们希望的是 1 秒后就能调用 callback。

这需要用到`jest.useFakeTimers`来 mock 定时器。它有一个好处，就是能够监听 setTimeout，并且对 setTimeout 进行一些断言。

```

```
