# 【设计理念】

## 架构的演进

让我们从一个很简单的功能着手：

```tsx
import React, { useState } from 'react';

export default function App() {
  const [state, setState] = useState(0);
  return (
    <div>
      <button onClick={() => setState(n => n + 1)}>click me</button>
      <div>{state}</div>
    </div>
  );
}
```

点击上面的按钮，视图上显示的值会加 1。

让我们看看 React15 是如何思考上面的功能的：

1. 通过一段描述（即 JSX）来告诉 React 你想要渲染怎样的 DOM 节点
2. 让 JSX 翻译成 虚拟 DOM，并交给 Renderer（渲染器）将虚拟 DOM 渲染成节点（mount 阶段）
3. 点击按钮后，通知 Reconciler（协调器）视图需要更新
4. Reconciler 内部产生新的虚拟 DOM，并将新旧虚拟 DOM 对比（Diff 算法）并提取出发生变化的部分。
5. 将产生差异的虚拟 DOM 交给 Renderer，Renderer 更新浏览器视图上的 DOM 节点

一张图表示 React15 的架构：

![image-20230119170342273](../assets/image-20230119170342273.png)

这个架构下，当数据不断更新时（假设用户不断点击按钮），会按照顺序做以下事情：

1. Reconciler 用 Diff 算法计算出需要更新的范围，并将结果提交给 Renderer
2. Renderer 根据差异结果更新真实的 DOM 节点
3. 浏览器视图发生变化
4. ... 上面的过程不断循环

整个处理过程像单一的队列般有序，最明显的是，整个过程是**同步**处理的。

这也意味着 React 的架构遇到了类似于 HTTP 的队首阻塞问题——一旦有一个地方产生了阻塞（用户的 input 行为造成大面积的视图更新时），浏览器忙于处理这些数据层面的运算导致页面卡顿。

而这个问题，使用`debounce`和`throttle`都不能很好地解决。

最佳的解决方式是**异步**，异步能通过优秀的调度来避免阻塞——浏览器已经证明了这一点。

在浏览器内部的异步 Schedule 中，采用双队列的形式来调度安排 JS 代码的执行并协调视图的更新。

为了达成异步更新以提高 React 的性能，React 重写源码升级了新的架构，新架构下 React 实现了一个**异步可中断**的 Scheduler（调度器）。

![image-20230119175452520](../assets/image-20230119175452520.png)

新架构下的更新规则变成了：

1. Scheduler 判断更新等级，是否有更高的优先级需要被调度
2. 如果没有则将更新交给 Reconciler
3. Reconciler 接受到更新并创建新的虚拟 DOM 树与旧的虚拟 DOM 做对比
4. 对比完成后给需要更新的 DOM 打上 Update 标记交给 Renderer
5. Renderer 更新视图上的真实 DOM

在新架构中，Scheduler 负责接受更新任务，并对更新任务的优先级进行排序。

当把 A 更新推送给 Reconciler 时，Reconciler 会进行 Diff 运算。在这过程中如果 Scheduler 又接收到一个更高级的 B 更新，则中断处理 A 更新的计算，转而再去计算 B 更新。
