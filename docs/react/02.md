# 【Diff 算法】

## Diff 算法的规则

在 React 16.8 后的实现上，**DIff 算法就是将 JSX 对象与 Current Fiber 节点做比较，然后根据对比结果构建出 workInProgress Fiber 节点。**

React 官方文档[reconciliation](https://zh-hans.reactjs.org/docs/reconciliation.html)说道：

> 在某一时间节点调用 React 的 `render()` 方法，会创建一棵由 React 元素组成的树。在下一次 state 或 props 更新时，相同的 `render()` 方法会返回一棵不同的树。React 需要基于这两棵树之间的差别来判断如何高效的更新 UI，以保证当前 UI 与最新的树保持同步。
>
> 此算法有一些通用的解决方案，即生成将一棵树转换成另一棵树的最小操作次数。然而，即使使用[最优的算法](http://grfia.dlsi.ua.es/ml/algorithms/references/editsurvey_bille.pdf)，该算法的复杂程度仍为 O(n 3 )，其中 n 是树中元素的数量。
>
> 如果在 React 中使用该算法，那么展示 1000 个元素则需要 10 亿次的比较。这个开销实在是太过高昂。于是 React 在以下两个假设的基础之上提出了一套 O(n) 的启发式算法：
>
> 1. 两个不同类型的元素会产生出不同的树；
> 2. 开发者可以使用 `key` 属性标识哪些子元素在不同的渲染中可能是不变的。
>
> 在实践中，我们发现以上假设在几乎所有实用的场景下都成立。

总结一下，React 的 O(n) 启发式算法是这样的：

1. 当根节点为不同类型的元素时，React 会拆卸原有的树并且建立起新的树。（这时候不走 diff 流程）

   用代码表示是这样的：

   ```js
   <div>
     <Counter />
   </div>
   // 变成了
   <span>
     <Counter />
   </span>
   ```

   React 会销毁 `Counter` 组件和 `div` 组件并且重新装载一个新的组件。

2. 当对比两个相同类型的 React 元素时，React 会保留 DOM 节点，仅比对及更新有改变的属性。

   ```js
   <div className="before" title="stuff" />

   <div className="after" title="stuff" />
   ```

   通过对比上面两个元素，会发现仅有 className 变化了，于是仅更新该 DOM 节点的 className

3. 对子节点进行递归

   默认情况下，当递归 DOM 节点的子元素时，React 会同时遍历两个子元素的列表；当产生差异时，生成一个 mutation。

   在子元素列表末尾新增元素时，更新开销比较小。比如：

   ```js
   <ul>
     <li>first</li>
     <li>second</li>
   </ul>

   <ul>
     <li>first</li>
     <li>second</li>
     <li>third</li>
   </ul>
   ```

   React 会先匹配两个 `<li>first</li>` 对应的树，然后匹配第二个元素 `<li>second</li>` 对应的树，最后插入第三个元素的 `<li>third</li>` 树。

   如果只是简单的将新增元素插入到表头，那么更新开销会比较大。比如：

   ```js
   <ul>
     <li>Duke</li>
     <li>Villanova</li>
   </ul>

   <ul>
     <li>Connecticut</li>
     <li>Duke</li>
     <li>Villanova</li>
   </ul>
   ```

   React 并不会意识到应该保留 `<li>Duke</li>` 和 `<li>Villanova</li>`，而是会重建每一个子元素。这种情况会带来性能问题。

4. 如果开发者用 key 标识的话，相同的 key 能够让 React 识别并尽可能地复用它。

   ```js
   <ul>
     <li key="2015">Duke</li>
     <li key="2016">Villanova</li>
   </ul>

   <ul>
     <li key="2014">Connecticut</li>
     <li key="2015">Duke</li>
     <li key="2016">Villanova</li>
   </ul>
   ```

   现在 React 知道只有带着 `'2014'` key 的元素是新元素，带着 `'2015'` 以及 `'2016'` key 的元素仅仅移动了。

以上总结是 React 为了方便开发者以及兼顾 Diff 更新性能所作出的规则，依据规则，就能写出性能更好的 React app。

从上面的介绍可以看出，Diff 算法分别考虑了子元素为多个以及子元素为 1 个（或 0 个）的处理情况。

这也就引出了多元素和单元素的 Diff 算法的不同处理方式。

## 单元素 Diff 算法

单元素的 Diff 指的是 React 对新的单元素和旧的单元素之间的数据比对。

```js
// before
<div>
  123
</div>
// after
<div>
  456
</div>
```

上面的 div 元素就是一个单元素。

React 对于单元素会进行以下步骤处理：

![diff](../assets/diff.png)

在 React 源码中，有一个[reconcileSingleElement](https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactChildFiber.new.js#L1142)函数，这个函数就是用来处理单元素。

它接受四个参数并返回一个 Fiber 数据结构：

```js
  function reconcileSingleElement(
    returnFiber: Fiber,
    currentFirstChild: Fiber | null,
    element: ReactElement,
    lanes: Lanes,
  ): Fiber
```

其中第二个参数指的是 `currentFiber` 节点，第三个参数`element` 是 JSX 返回的对象。

当`ReactDOM.render`首次挂载组件时，此时只有 RootFIber ，workInProgress 还没有完整的 Fiber 节点，所以会执行[createFiberFromElement](https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactChildFiber.new.js#L1234)方法创建 Fiber 节点。

当触发 update 更新时，element 与 currentFiber 做比较，最终生成 `workInProgress Fiber`。

那么判断节点是否可以复用的根据是什么呢？

要想复用有两个前提：

1. 节点的 tag 是否相同
2. 节点的 key 是否相同

以下面的 React 元素为例：

```js
// before
<div>
  123
</div>
// after
<div>
  456
</div>
```

在更新前，它的 `tag` 是`div`。更新后， `tag` 依然是`div`。

在更新前，它的`key`是`undefined`。更新后，`key`依然是`undefined`。

所以它满足复用的条件。

具体的判断逻辑代码是这样的：

```js
function reconcileSingleElement(
  returnFiber: Fiber,
  currentFirstChild: Fiber | null,
  element: ReactElement,
): Fiber {
  const key = element.key;
  let child = currentFirstChild;

  // 首先判断是否存在对应DOM节点
  while (child !== null) {
    // 上一次更新存在DOM节点，接下来判断是否可复用

    // 首先比较key是否相同
    if (child.key === key) {
      // key相同，接下来比较type是否相同

      switch (child.tag) {
        // ...省略case

        default: {
          if (child.elementType === element.type) {
            // type相同则表示可以复用
            // 返回复用的fiber
            const existing = useFiber(child, element.props);
            // ...省略部分代码
            return existing;
          }

          // type不同则跳出switch
          break;
        }
      }
      // 代码执行到这里代表：key相同但是type不同
      // 将该fiber及其兄弟fiber标记为删除
      deleteRemainingChildren(returnFiber, child);
      break;
    } else {
      // key不同，将该fiber标记为删除
      deleteChild(returnFiber, child);
    }
    child = child.sibling;
  }

  // 创建新Fiber，并返回 ...省略
}
```

可以看出`reconcileSingleElement`方法主要是在 while 循环中做`switch` 判断：

先判断 key 是否相同，如果 key 相同则判断 type 是否相同，只有都相同时才会走复用的逻辑。

当可以复用时，会进入 useFiber 方法，这个方法会根据 current Fiber 返回克隆后的新的 Fiber 节点。

```js
function useFiber(fiber: Fiber, pendingProps: mixed): Fiber {
  // We currently set sibling to null and index to 0 here because it is easy
  // to forget to do before returning it. E.g. for the single child case.
  const clone = createWorkInProgress(fiber, pendingProps);
  clone.index = 0;
  clone.sibling = null;
  return clone;
}
```

此外有个细节：

- 当`child !== null`且`key相同`且`type不同`时执行`deleteRemainingChildren`将`child`及其兄弟`fiber`都标记删除。
- 当`child !== null`且`key不同`时仅将`child`标记删除。

这个代码适用于以下情况：

当前页面有 3 个`li`，我们要全部删除，再插入一个`p`。

```js
// 当前页面显示的
ul > li * 3;

// 这次需要更新的
ul > p;
```

由于本次更新时只有一个`p`，属于单一节点的`Diff`，会走`reconcileSingleElement`逻辑。

在`reconcileSingleElement`中遍历之前的 3 个`fiber`（对应的`DOM`为 3 个`li`），寻找本次更新的`p`是否可以复用之前的 3 个`fiber`中某个的`DOM`。

当`key相同`且`type不同`时，代表我们已经找到本次更新的`p`对应的上次的`fiber`，但是`p`与`li` `type`不同，不能复用。既然唯一的可能性已经不能复用，则剩下的`fiber`都没有机会了，所以都需要标记删除——调用 `deleteRemainingChildren`方法。

当`key不同`时只代表遍历到的该`fiber`不能被`p`复用，后面还有兄弟`fiber`还没有遍历到。所以仅仅标记该`fiber`删除——调用`deleteChild`方法。

## 多节点 Diff 算法
