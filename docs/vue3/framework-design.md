---
order: 1
---

# 框架设计

## 1.1 命令式和声明式

视图框架分为命令式和声明式两种。

- 命令式

  特点是关注过程。典型代表是 jQuery。

  命令式就是用指令的形式编码来完成功能。比如以下代码：

  ```js
  const div = document.querySelector('#app'); // 获取 div
  div.innerText = 'hello world'; // 设置文本内容
  div.addEventListener('click', () => {
    alert('ok');
  }); // 绑定点击事件
  ```

  代码本身描述的是做事的过程。自然语言能够与代码形成一一对应的关系。

- 声明式

  声明式框架更关注的是结果。上面的代码可以用 Vue 这样实现：

  ```html
  <div @click="()=>alert('ok')">hello world</div>
  ```

  可以看到，我们直接提供了一个结果，而实现结果的过程，则是 Vue 帮我们完成的。换句话说，Vue 帮助我们实现了过程的封装。因此，Vue 的内部实现是指令式的，而暴露给用户的是声明式的 API。

## 1.2 性能与可维护性

**声明式代码的性能不优于命令式代码的性能。**

如果我们想要修改上面例子中 div 的文本内容，那可以调用以下命令来操作：

```js
div.textContent = 'hello vue3';
```

没什么代码能够比上面的代码性能更好。理论上命令式的代码可以做到极致的性能优化。因为我们明确知道哪些东西需要变更，只需要做必要的修改即可。但是声明式的代码不一定能做到这点，因为它描述的是结果：

```html
// 之前
<div @click="()=>alert('ok')">hello world</div>
// 之后
<div @click="()=>alert('ok')">hello vue3</div>
```

为了实现最优的更新性能，框架需要找到前后的差异并且只更新变化的部分。但最终完成本次更新的代码依然会是：

```js
div.textContent = 'hello vue3';
```

由此我们可以得出两个公式：

```
命令式代的更新性能消耗 = A
声明式代码的更新性能消耗 = B + A
```

可以看到，声明式代码的更新性能消耗会比命令式的多出寻找差异的性能消耗。因此，最理想的情况就是，找差异的性能消耗为 0 时，声明式代码会跟命令式的代码性能消耗持平。

**框架本身就是封装了命令式代码才实现了面向用户的声明式**，因此我们得出开头的结论：

**声明式代码的性能不优于命令式代码的性能。**

但是**声明式代码的性能不优于命令式代码的性能。**。

在采用命令式开发时，我们需要维护实现的目标的整个过程，包括手动完成 DOM 元素的增删改查。而声明式的代码展示的是结果，看上去更加直观。

因此，声明式框架的设计者要做的就是：**在保持可维护性的同时让性能损失最小化**。

## 1.3 虚拟 DOM 的性能

**声明式代码的更新性能消耗 = 找出差异的性能消耗 + 直接修改的性能消耗**

因此，如果我们能够将找出差异的性能消耗降低到最低，就可以让声明式的代码无限接近于命令式代码的性能。

虚拟 DOM 就是**为了最小化找出差异的性能消耗**而出现的。

所以，理论上来说，虚拟 DOM 的更新技术不可能比原生 JavaScript 操作 DOM 的性能更高。

但是大部分情况下，我们很难写出绝对优化的命令式代码。

所以虚拟 DOM 要解决的问题就是让我们写声明式代码的情况下，保证应用程序的下限，并且想办法逼近命令式代码的性能。

以下是 InnerHTML、虚拟 DOM、纯 DOM 操作方法在创建 `DOM` 时的性能差异：

- **InnerHTML 性能消耗**

  不同于 `document.createElement`等现代 DOM 操作的 API。`innerHTML` 能够用 HTML 字符串的形式直接构建标签进而生成 DOM。

  比如下面的代码：

  ```html
  div.innerHTML = `
  <div><span>...</span></div>
  `;
  ```

  为了渲染出页面，上面的 HTML 字符串会被解析成 DOM 树，这涉及 DOM 的运算。

  用一个公式来表达通过 innerHTML 创建页面的性能：**HTML 字符串拼接的计算量+innerHTML 的 DOM 计算量**

- **虚拟 DOM 性能消耗**

  虚拟 DOM 创建页面的过程分为两步：

  1. 创建 JavaScript 对象，这个对象可以理解为真实 DOM 的描述。
  2. 递归遍历虚拟 DOM 并创建真实 DOM。

  用一个公式来表达虚拟 DOM 的性能：**创建 JavaScript 对象的计算量+创建真实 DOM 的计算量**

- **纯 `JavaScript` 性能消耗**

  纯 JavaScript 就是采用现代 DOM 操作的方法，例如使用 `createElement`等 API 来直接创建 DOM 元素。

  那它的性能公式为：**创建真实 DOM 的计算量**
